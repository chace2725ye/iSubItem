# iSubItem
 SendMessageString($Sci, $SCI_AUTOCSHOW, StringLen($Word), $AllVariables)                                                      ElseIf StringLen($Word) Then  ;~                              If Not SendMessage($Sci, $SCI_AUTOCACTIVE, 0,0) Then ;~                          ConsoleWrite($Word &amp; @CRLF)                             If StringRegExp($Word, "\A[A-Za-z0-9_@#]+\Z") Then ;And StringInStr(@CR &amp; $SCI_AUTOCLIST,@CR &amp; $Word,0) Then                                 Local $pos = ArraySearchAll($SCI_AUTOCLIST, $Word, 1, 0, 1)                                 If $pos = -1 Then Return 'GUI_RUNDEFMSG' ;~                                  _ArraySort($SCI_AUTOCLIST,0,1)                                 $AllVariables = _ArrayToString($SCI_AUTOCLIST, @CR, $pos[0], $pos[UBound($pos) - 1])                                  ;~                                  $AllVariables = _ArrayToString($SCI_AUTOCLIST, @CR,1) ;~                                      ConsoleWrite($AllVariables &amp; @CRLF)                                 $err = SendMessageString($Sci, $SCI_AUTOCSHOW, StringLen($Word), $AllVariables) ;~                                      ConsoleWrite($err &amp; @CRLF)                             EndIf ;~                              EndIf                                                                                   EndIf                     EndIf ;~                      #CE ;~          EndIf             EndSwitch         Case $SCN_MARGINCLICK             SendMessage($Sci, $SCI_TOGGLEFOLD, $line_number, 0)                      Case $SCN_SAVEPOINTREACHED                      Case $SCN_SAVEPOINTLEFT                  EndSwitch     ;EndIf     ;EndSelect     $structNMHDR = 0     $event = 0     $lParam = 0     Return 'GUI_RUNDEFMSG' EndFunc   ;==>SCI_AU3_WM_NOTIFY  ;Prog@ndy, modified _ArraySearch Func ArraySearchAll(Const ByRef $avArray, $vValue, $iStart = 0, $iEnd = 0, $iPartialfromBeginning = 0, $iForward = 1, $iSubItem = 0)     If Not IsArray($avArray) Then Return SetError(1, 0, -1)      Local $iUBound = UBound($avArray) - 1          ; Bounds checking     If $iEnd &lt; 1 Or $iEnd > $iUBound Then $iEnd = $iUBound     If $iStart &lt; 0 Then $iStart = 0     If $iStart > $iEnd Then Return SetError(4, 0, -1)     If $vValue = "" And $iPartialfromBeginning = True Then Return SetError(8, 0, -1)      ; Direction (flip if $iForward = 0)     Local $iStep = 1     If Not $iForward Then         Local $iTmp = $iStart         $iStart = $iEnd         $iEnd = $iTmp         $iStep = -1     EndIf     Local $ResultsArray[$iUBound + 1], $ResultIndex = 0     Local $iLenValue = StringLen($vValue)     ; Search     Switch UBound($avArray, 0)         Case 1 ; 1D array search             If Not $iPartialfromBeginning Then                 For $i = $iStart To $iEnd Step $iStep                     If $avArray[$i] = $vValue Then                         $ResultsArray[$ResultIndex] = $i                         $ResultIndex += 1                     EndIf                 Next             Else                 For $i = $iStart To $iEnd Step $iStep                     If StringLeft($avArray[$i], $iLenValue) = $vValue Then                         $ResultsArray[$ResultIndex] = $i                         $ResultIndex += 1                     EndIf                 Next             EndIf         Case 2 ; 2D array search             Local $iUBoundSub = UBound($avArray, 2) - 1             If $iSubItem &lt; 0 Then $iSubItem = 0             If $iSubItem > $iUBoundSub Then $iSubItem = $iUBoundSub              If Not $iPartialfromBeginning Then                 For $i = $iStart To $iEnd Step $iStep                     If $avArray[$i][$iSubItem] = $vValue Then                         $ResultsArray[$ResultIndex] = $i                         $ResultIndex += 1                     EndIf                 Next             Else                 For $i = $iStart To $iEnd Step $iStep                     If StringLeft($avArray[$i][$iSubItem], $iLenValue) = $vValue Then                         $ResultsArray[$ResultIndex] = $i                         $ResultIndex += 1                     EndIf                 Next             EndIf         Case Else             Return SetError(7, 0, -1)     EndSwitch      If $ResultIndex = 0 Then Return SetError(6, 0, -1)     ReDim $ResultsArray[$ResultIndex]     Return $ResultsArray EndFunc   ;==>ArraySearchAll  ; Author: Prog@ndy ; If the equal entries are one after the other, delete them :) Func ArraySortUnique(ByRef $avArray, $iDescending = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0)     Local $ret = _ArraySort($avArray, $iDescending, $iStart, $iEnd, $iSubItem)     If @error Then Return SetError(@error, 0, $ret)     Local $ResultIndex = 1, $ResultArray[UBound($avArray)]     $ResultArray[0] = $avArray[0]     For $i = 1 To UBound($avArray) - 1         If Not ($avArray[$i] = $avArray[$i - 1]) Then             $ResultArray[$ResultIndex] = $avArray[$i]             $ResultIndex += 1         EndIf     Next     ReDim $ResultArray[$ResultIndex]     $avArray = $ResultArray     Return 1 EndFunc   ;==>ArraySortUnique
